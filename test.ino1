#include <ESP8266WiFi.h>
#include <ESP8266WiFiMulti.h>
#include "AudioFileSourceICYStream.h"//ESP8266Audio-master_mod_espmini.zip (прилагается к проекту)
#include "AudioFileSourceBuffer.h" //ESP8266Audio-master_mod_espmini.zip (прилагается к проекту)
#include "AudioGeneratorMP3.h"
#include "AudioOutputI2SNoDAC.h"
extern "C" {
#include <user_interface.h>
}
#define _DEBUG
#include "MyArduino.h"

ESP8266WiFiMulti WiFiMulti;

#define PIN_MUTE D6 //GPIO12

AudioGeneratorMP3* mp3;
AudioFileSourceICYStream* file;
AudioFileSourceBuffer* buff;
AudioOutputI2SNoDAC* out;

bool upWiFi() {
	static unsigned long lastConnectedTime = millis();
	int iTry = 0;
	//return false;
	while (WiFi.status() != WL_CONNECTED && WiFiMulti.run() != WL_CONNECTED) {
		if (iTry++ == 8) break; // ESP.reset();
		DEBUG_PRINT("...try con WiFi.status() = %i\n", WiFi.status());
		delay(500);
	}

	bool ret = WiFi.status() == WL_CONNECTED;
	if (ret) {
		lastConnectedTime = millis();
		DEBUG_PRINT("%s connected to \"%s\" %idBm at chanel %i\n", "radio_test", WiFi.SSID().c_str(), WiFi.RSSI(), WiFi.channel());
	}
	else if (millis() - lastConnectedTime >= 20000L) ESP.restart();
	return ret;
}

// Called when a metadata event occurs (i.e. an ID3 tag, an ICY block, etc.
void MDCallback(void* cbData, const char* type, bool isUnicode, const char* string)
{
	const char* ptr = reinterpret_cast<const char*>(cbData);
	(void)isUnicode; // Punt this ball for now
	// Note that the type and string may be in PROGMEM, so copy them to RAM for printf
	char s1[32], s2[64];
	strncpy_P(s1, type, sizeof(s1));
	s1[sizeof(s1) - 1] = 0;
	strncpy_P(s2, string, sizeof(s2));
	s2[sizeof(s2) - 1] = 0;
	Serial.printf("METADATA(%s) '%s' = '%s'\n", ptr, s1, s2);
	Serial.flush();
}

// Called when there's a warning or error (like a buffer underflow or decode hiccup)
void StatusCallback(void* cbData, int code, const char* string)
{
	const char* ptr = reinterpret_cast<const char*>(cbData);
	// Note that the string may be in PROGMEM, so copy it to RAM for printf
	char s1[64];
	strncpy_P(s1, string, sizeof(s1));
	s1[sizeof(s1) - 1] = 0;
	Serial.printf("STATUS(%s) '%d' = '%s'\n", ptr, code, s1);
	Serial.flush();
}

void setup()
{
	system_update_cpu_freq(SYS_CPU_160MHZ);
	Serial.begin(115200);
	pinMode(PIN_MUTE, OUTPUT);
	digitalWrite(PIN_MUTE, LOW);
	DEBUG_PRINT("\nStart...\n\n");
	delay(1000);
	
	WiFi.mode(WIFI_STA);
	WiFiMulti.addAP("BogdanWiFi", "BcqBd2ng");
	WiFiMulti.addAP("BogdanAsusWiFi", "BcqBd2ng");
	WiFiMulti.addAP("BogdanZyxelWiFi", "BcqBd2ng");

	if (upWiFi()) {
		file = new AudioFileSourceICYStream();
		file->RegisterMetadataCB(MDCallback, (void*)"ICY");
		file->format_file("audio/mpeg");//проверка заголовка потока, пропускаем только mpeg потоки
		if (file->open("http://ep128.hostingradio.ru:8030/ep128")) {
			buff = new AudioFileSourceBuffer(file, 2048);//конфигурируем буфер
			buff->RegisterStatusCB(StatusCallback, (void*)"buffer");
			out = new AudioOutputI2SNoDAC();
			mp3 = new AudioGeneratorMP3();//назначаем декодер потока
			mp3->RegisterStatusCB(StatusCallback, (void*)"mp3");
			mp3->begin(buff, out);//запускаем поток
		}
		else {
			DEBUG_PRINT("Err open stream!");
			while (1) yield();
		}
	}
	else {
		DEBUG_PRINT("No WiFi!");
		while (1) yield();
	}
	DEBUG_PRINT("\nPlay, unmute...\n\n");
	digitalWrite(PIN_MUTE, HIGH);
}

void loop()
{
	static int lastms = 0;

	if (mp3->isRunning()) {
		if (millis() - lastms > 1000) {
			lastms = millis();
			Serial.printf("Running for %d ms...\n", lastms);
			Serial.flush();
		}
		if (!mp3->loop()) mp3->stop();
	}
	else {
		Serial.printf("MP3 done\n");
		delay(1000);
	}
}
